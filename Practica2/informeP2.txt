Óscar Vilela Rodríguez y Ainhoa de Diego Silva 
oscar.vilela.rodriguez@udc.es; ainhoa.dediego.silva@udc.es

INTRODUCCIÓN

En esta segunda práctica analizamos y demostramos de manera empírica la fiabilidad, tiempo de ejecución, y complejidad de dos algoritmos de ordenación propuestos que realizan la ordenación de un vector, que se inizializa de tres formas posibles; ascedente (caso mejor), descendente (caso peor) y aleatorio (caso medio). Para ello, creamos un programa en Python, compuesto de varios archivos de código: 

Algoritmos.py 
FuncionesTests.py 
FuncionesAuxiliares.py 
Main.py

ACLARACIONES INICIALES

Para ejecutar el código debes moverte al directorio y escribir en la terminal python main.py.

Las características de la máquina que usamos se muestran a continuación: 

Nombre del modelo: Lenovo Legion 5 15ITH6H Intel Core i7-11800H/32GB/1TB SSD/RTX3070/15.6" 
Procesador Intel Core i7-11800H (8C / 16T, 2.3 / 4.6GHz, 24MB) 
Memoria RAM 2x 16GB SO-DIMM DDR4-3200 
Almacenamiento 1TB SSD M.2 2280 PCIe 3.0x4 NVMe 


*Este programa en específico se ejecutó en el procesador (CPU) por lo que la tarjeta gráfica (GPU) no es necesaria para su ejecución. 
*Todas las medidas de tiempo han sido tomadas en nanosegundos (ns), mediante la función 	time.perf_counter_ns() , y mostradas por pantalla a su vez en nanosegundos. 
*Todas las funciones aquí comentadas están descritas en mayor profundidad en el código. 


Una vez aclaradas las cuestiones básicas, explicaremos paso a paso, el proceso que nos llevó a las conclusiones finales de este informe.

DESARRROLLO DE LAS PRUEBAS

1º Creamos el archivo Algoritmos.py en el que definimos las funciones de los algoritmos a comprobar. 

2º Comprobamos el correcto funcionamiento de los dos algoritmos y la complejidad algorítmica de forma empírica: 

3º Para comprobar el tiempo de ejecución, creamos la función test_tiempo_complejidad(algoritmo, func_type, exp1, exp2, exp3) que calcula el tiempo y nos permite medir la complejidad de manera empírica gracias a las cotas.

CONCLUSIONES