Óscar Vilela Rodríguez y Ainhoa de Diego Silva 
oscar.vilela.rodriguez@udc.es; ainhoa.dediego.silva@udc.es

INTRODUCCIÓN

En esta cuarta práctica analizamos y demostramos de manera empírica la fiabilidad, tiempo de ejecución, y 
complejidad del algoritmo de Dijkstra propuesto, que realiza la busqueda del camino minimo (más corto, de modo que la suma de los pesos de las aristas sea la menor) entre los nodos de un grafo completo, no dirigído y ponderado
donde el peso de cada arista se inizializa de forma aleatoria, tomando valores de [1...1000] 

Esta función requiere como variable de entrada la matriz de adyacencia del grafo, que es la que nos proporciona todos los pesos de las aristas existentes.
Para ello fué necesario la creación de la función matrizAleatoria(), que es la que se usa para crear la matriz que representará el grafo,
es decir, la matriz de adyacencia donde se encontrarán los pesos [1...1000], excepto la diagonal principal, ya que el grafo es simple (sin aristas múltiples, ni lazos)
Para ello, creamos un programa en Python, compuesto de varios archivos de código: 

Algoritmos.py 
FuncionesTests.py 
FuncionesAuxiliares.py 
Main.py

ACLARACIONES INICIALES

Para ejecutar el código debes moverte al directorio y escribir en la terminal python main.py.

Las características de la máquina que usamos se muestran a continuación: 

Nombre del modelo: Microsoft Surface Laptop Go 2 
Procesador 11th Gen Intel(R) Core(TM) i5-1135G7 @2.40 GHz, 2419 MHz (4 procesadores principales, 8 procesadores lógicos)
Memoria RAM  8 GB de RAM LPDDR4x
Almacenamiento 256 GB SSD
Python 3.9.13

*Este programa en específico se ejecutó en el procesador (CPU) por lo que la tarjeta gráfica (GPU) no es necesaria para su ejecución. 
*Todas las medidas de tiempo han sido tomadas en nanosegundos (ns), mediante la función time.perf_counter_ns(), y 
 mostradas por pantalla a su vez en nanosegundos. 

*Todas las funciones aquí comentadas están descritas en mayor profundidad en el código. 


Una vez aclaradas las cuestiones básicas, explicaremos paso a paso, el proceso que nos llevó a las conclusiones finales de este informe.


DESARRROLLO DE LAS PRUEBAS



1º Creamos el archivo Algoritmos.py en el que definimos la función dijkstra.



2º Comprobamos el correcto funcionamiento del algoritmo y la complejidad algorítmica de forma empírica:
Para ello creamos el archivo FuncionesTests.py, que a su vez utiliza otras funciones definidas en FuncionesAuxiliares.py, donde definimos las funciones “test”: 

TEST 1
Matriz del caso 1:
[    0,     1,     8,     4,     7]
[    1,     0,     2,     6,     5]
[    8,     2,     0,     9,     5]
[    4,     6,     9,     0,     3]
[    7,     5,     5,     3,     0]

Calculamos la matriz de adyacencia de caminos de peso mínimo para la matriz del caso 1:
    0    1    2    3    4
   --------------------------

0  | 0    1    3    4    6

1  | 1    0    2    5    5

2  | 3    2    0    7    5

3  | 4    5    7    0    3

4  | 6    5    5    3    0

Matriz del caso 2:
[    0,     1,     4,     7]
[    1,     0,     2,     8]
[    4,     2,     0,     3]
[    7,     8,     3,     0]

Calculamos la matriz de adyacencia de caminos de peso mínimo para la matriz del caso 2:
Matriz aleatoria:
[    0,    32,   321,   383,   443,   806,   675,   311,   110,   178]
[   32,     0,   108,   379,   350,    68,    19,   998,   923,   487]
[  321,   108,     0,   586,   974,   123,   202,   206,   137,   769]
[  383,   379,   586,     0,   297,   868,   815,   598,   633,   335]
[  443,   350,   974,   297,     0,   877,   574,   586,   236,   168]
[  806,    68,   123,   868,   877,     0,   248,   602,   412,   104]
[  675,    19,   202,   815,   574,   248,     0,   728,   210,   918]
[  311,   998,   206,   598,   586,   602,   728,     0,   660,   662]
[  110,   923,   137,   633,   236,   412,   210,   660,     0,   198]
[  178,   487,   769,   335,   168,   104,   918,   662,   198,     0]

Calculamos la matriz de adyacencia de caminos de peso mínimo para una matriz aleatoria:
    0    1    2    3    4    5    6    7    8    9
   ---------------------------------------------------

0  | 0    32   140  383  346  100  51   311  110  178

1  | 32   0    108  379  340  68   19   314  142  172

2  | 140  108  0    487  373  123  127  206  137  227

3  | 383  379  487  0    297  439  398  598  493  335

4  | 346  340  373  297  0    272  359  579  236  168

5  | 100  68   123  439  272  0    87   329  210  104

6  | 51   19   127  398  359  87   0    333  161  191

7  | 311  314  206  598  579  329  333  0    343  433

8  | 110  142  137  493  236  210  161  343  0    198

9  | 178  172  227  335  168  104  191  433  198  0

3º Para comprobar el tiempo de ejecución del algoritmo, creamos una función 
def test_tiempo_complejidad(alg, orden, exp1, exp2, exp3) que calcula
el tiempo y nos permite medir la complejidad de manera empírica gracias a las cotas.

                                                   Subestimada    Ajustada        Sobreestimada
           n                  t(n) (ns)            t(n)/n^2.8     t(n)/n^2.95     t(n)/n^3.1
*         10                154271.7000            244.504167   # 173.095694      122.542367 (promedio de 1000 repeticiones)
*         20               1027386.3000            233.802840     149.174738      95.178922  (promedio de 1000 repeticiones)
          40               7731500.0000            252.636319     145.273629      83.536791
          80              59824700.0000            280.691050     145.467196      75.387887
         160             433063500.0000            291.753201     136.269177      63.647249
         320            3434619500.0000            332.245182     139.857640      58.872665
         640           28045988900.0000            389.553249     147.788225      56.067713

                                                   Subestimada    Ajustada        Sobreestimada
           n                  t(n) (ns)            t(n)/n^2.8     t(n)/n^2.95     t(n)/n^3.1
*         10                148394.1000            235.188799   # 166.500919      117.873623 (promedio de 1000 repeticiones)
*         20               1022226.7000            232.628667     148.425573      94.700928  (promedio de 1000 repeticiones)
          40               6654100.0000            217.430942   # 125.029458      71.895772
          80              55435300.0000            260.096458     134.794118      69.856600
         160             414288700.0000            279.104691     130.361437      60.887920
         320            3353290100.0000            324.377847     136.545908      57.478602
         640           27481901700.0000            381.718189     144.815770      54.940026

Cota subestimada. 2.8. El tiempo de ejecución entre la cota tiende a infinito.
Cota ajustada. 2.95. El tiempo de ejecución entre la cota tiende a una constante aproximada a un rango de valores [135, 145].
Cota sobreestimada. 3.1. El tiempo de ejecución entre la cota tiende a 0.

Teoricámente la complejidad del algoritmo dijkstra sería O(n^3) pero difiere con la comprobación empírica:
                                                   Subestimada    Ajustada        Sobreestimada
           n                  t(n) (ns)            t(n)/n^2.8     t(n)/n^3        t(n)/n^3.1
*         10                153183.9000            242.780120     153.183900      121.678297 (promedio de 1000 repeticiones)
*         20               1017382.5000            231.526270     127.172813      94.252152  (promedio de 1000 repeticiones)
          40               7118100.0000            232.592716     111.220313      76.909168
          80              60181700.0000            282.366056     117.542383      75.837759
         160             405663000.0000            273.293591     99.038818       59.620203
         320            3376884000.0000            326.660185     103.054321      57.883024
         640           27760805700.0000            385.592110     105.899070      55.497593

Utilizamos un vector de progresión geométrica 2 porque nos ayuda a visualizar hacia qué valor de tiempo tiende el algoritmo.
Los asteriscos en las tablas de datos simbolizan que esos valores están por debajo del umbral de confianza, por lo que utilizamos 
el método del promedio para tener una medida más precisa.

Para intentar evitar datos anómalos, ejecutamos el código en un entorno lo más limpio posible, con el menor número de procesos en 
segundo plano, con un número de iteraciones totales de 10.

Para indicar los datos anómalos, los marcamos en las tablas de los tiempos de ejecución con el símbolo "#".

CONCLUSIONES
 
Para el algoritmo dijkstra suponemos las cotas subestimada, ajustada y sobreestimada con el fin de averiguar su complejidad
de manera empírica.

Para suponer la complejidad del algoritmo de forma empírica, comparamos las cotas y los tiempos de ejecución resultantes, dando 
como complejidad resultante sería O(n^2.95), la cuál difiere de forma escasa con la complejida teórica (O(n^3)). 

Por tanto, concluímos que la complejidad aproximada del algoritmo dijkstra sería O(n^3).

