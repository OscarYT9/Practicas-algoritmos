Óscar Vilela Rodríguez y Ainhoa de Diego Silva 
oscar.vilela.rodriguez@udc.es; ainhoa.dediego.silva@udc.es 

Introducción 

En esta primera práctica analizamos y demostramos de manera empírica la fiabilidad, tiempo de ejecución, y complejidad de dos algoritmos propuestos que realizan la suma de la subsecuencia máxima con diferente implementación. Para ello, creamos un programa en Python, compuesto de varios archivos de código: 

Algoritmos.py 
FuncionesTests.py 
FuncionesAuxiliares.py 
Main.py 

Aclaraciones iniciales: 

    Las características de la máquina que usamos se muestran a continuación: 

    Nombre del modelo: Lenovo Legion 5 15ITH6H Intel Core i7-11800H/32GB/1TB SSD/RTX3070/15.6" 
    Procesador Intel Core i7-11800H (8C / 16T, 2.3 / 4.6GHz, 24MB) 
    Memoria RAM 2x 16GB SO-DIMM DDR4-3200 
    Almacenamiento 1TB SSD M.2 2280 PCIe 3.0x4 NVMe 


    *Este programa en específico se ejecutó en el procesador (CPU) por lo que la tarjeta gráfica (GPU) no es necesaria para su ejecución. 
    *Todas las medidas de tiempo han sido tomadas en nanosegundos (ns), mediante la función 	time.perf_counter_ns() , y mostradas por pantalla a su vez en nanosegundos. 
    *Todas las funciones aquí comentadas están descritas en mayor profundidad en el código. 

 

 Una vez aclaradas las cuestiones básicas, explicaremos paso a paso, el proceso que nos llevó a las conclusiones del final de este informe: 

 

1º Creamos el archivo Algoritmos.py en el que colocamos las funciones que definen los algoritmos a comprobar. 

Algoritmos.py 

Este código está compuesto por los dos algoritmos a comprobar, cada uno en una función, denominados sumaSubMax1 y sumaSubMax2. Estos resuelven el problema de la suma de la subsecuencia máxima, iterando cada elemento del vector o lista recibido como entrada. 

sumaSubMax1(v: list) -> int: 

	El algoritmo recorre el vector v y calcula la suma de todas las subsecuencias posibles. Luego, 	compara cada suma con la suma máxima encontrada hasta ese momento y actualiza la suma 	máxima si se encuentra una suma mayor. 

sumaSubMax2(v: list) -> int. 

	El algoritmo recorre el vector v una vez y calcula la suma acumulativa de los elementos. Si en 	algún punto la suma acumulativa se vuelve negativa, se reinicia a cero. Mientras se recorre 	el arreglo, se lleva un registro de la suma máxima encontrada hasta ese momento. 

 

2º Comprobamos el correcto funcionamiento de los dos algoritmos y la complejidad algorítmica de forma empírica: 

	Para ellos creamos el archivo FuncionesTests.py donde definimos las funciones “test”: 

test_resultados	: nos permite resolver el problema que se plantea con cada algoritmo 

Test 1 (Casos de Prueba): 

[-9,  2, -5, -4,  6] 	 6 	 6 	- True 

[ 4,  0,  9,  2,  5] 	 20 	 20 	- True 

[-2, -1, -9, -7, -1] 	 0 	 0 	- True 

[ 9, -2,  1, -7, -8] 	 9 	 9 	- True 

[15, -2, -5, -4, 16] 	 20 	 20 	- True 

[ 7, -5,  6,  7, -7] 	 15 	 15 	- True 

  

Test 2 (Vectores Aleatorios): 

[ 1,  9, -9,  1, -1, -8, -9,  3,  6] 	 10 	 10 	- True 

[-5,  4, -1,  5, -9, -7,  7,  4, -1] 	 11 	 11 	- True 

[-4, -4,  2, -9, -7, -4,  8, -6, -4] 	 8 	 8 	- True 

[ 5, -6,  9, -8, -6, -7,  8,  8,  2] 	 18 	 18 	- True 

[-8, -3,  4,  6,  2, -6, -3, -5,  2] 	 12 	 12 	- True 

[ 2, -2, -8,  3,  0,  1,  2,  2,  1] 	 9 	 9 	- True 

[-9,  3, -1, -7, -1,  5, -5, -1,  8] 	 8 	 8 	- True 

[-5,  3, -4,  8,  9, -2,  8, -1,  1] 	 23 	 23 	- True 

[-6,  5, -5,  0, -3, -2, -6,  3, -6] 	 5 	 5 	- True 