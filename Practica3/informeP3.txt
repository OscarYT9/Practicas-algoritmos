#Repetir K 1000 veces, en la función de calcular promedio (debes repetir 1000 veces la ejecución)
#Hacer dos funciones, una que imprima las tablas y otra que la calculé (que calcule el tiempo_de ejecución)

Óscar Vilela Rodríguez y Ainhoa de Diego Silva 
oscar.vilela.rodriguez@udc.es; ainhoa.dediego.silva@udc.es

INTRODUCCIÓN

En esta tercera práctica analizamos y demostramos de manera empírica la fiabilidad, tiempo de ejecución, y complejidad de de dos algoritmos propuestos: crearMonticulo, y ordenacionPorMonticulos que realiza la ordenación ascedente de un vector, que se inizializa de tres formas posibles; ascedente, descendente y aleatorio. Ambas funciones requieren la implementación de un monticulo de mínimos para su ejecución por lo que hubo que implementar una clase montículo con los métodos de crearMonticulo, consultarMenor, quitarMenor y __hundir. Para ello, creamos un programa en Python, compuesto de varios archivos de código: 

Algoritmos.py 
FuncionesTests.py 
FuncionesAuxiliares.py 
Main.py

ACLARACIONES INICIALES

Para ejecutar el código debes moverte al directorio y escribir en la terminal python main.py.

Las características de la máquina que usamos se muestran a continuación: 

Nombre del modelo: Lenovo Legion 5 15ITH6H Intel Core i7-11800H/32GB/1TB SSD/RTX3070/15.6" 
Procesador Intel Core i7-11800H (8C / 16T, 2.3 / 4.6GHz, 24MB) 
Memoria RAM 2x 16GB SO-DIMM DDR4-3200 
Almacenamiento 1TB SSD M.2 2280 PCIe 3.0x4 NVMe 
Python 3.9.12

*Este programa en específico se ejecutó en el procesador (CPU) por lo que la tarjeta gráfica (GPU) no es necesaria para su ejecución. 
*Todas las medidas de tiempo han sido tomadas en nanosegundos (ns), mediante la función 	time.perf_counter_ns() , y mostradas por pantalla a su vez en nanosegundos. 
*Todas las funciones aquí comentadas están descritas en mayor profundidad en el código. 


Una vez aclaradas las cuestiones básicas, explicaremos paso a paso, el proceso que nos llevó a las conclusiones finales de este informe.

DESARRROLLO DE LAS PRUEBAS

1º Creamos el archivo Algoritmos.py en el que definimos las funciones de los algoritmos a comprobar.

class Monticulo:
    def crearMonticulo(self, v):
    def consultarMenor(self):
    def quitarMenor(self):
    def __hundir(self, i):

def ordenacionPorMonticulos(V):

2º Comprobamos el correcto funcionamiento de los dos algoritmos y la complejidad algorítmica de forma empírica:

Para ello creamos el archivo FuncionesTests.py, que a su vez utiliza otras funciones definidas en FuncionesAuxiliares.py, donde definimos las funciones “test”: 

def probar_operaciones_monticulo(n,orden):
def probar_algoritmo_ordenación(n,orden):











3º Para comprobar el tiempo de ejecución de los dos algoritmos (el de creación y ordenación), creamos dos funciones funciones test_tiempo_complejidad_crearMonticulo(orden, exp1, exp2, exp3): y test_tiempo_complejidad_ordenacionPorMonticulos(orden) que calculan el tiempo y nos permite medir la complejidad de manera empírica gracias a las cotas.
Utilizamos un vector de progresión geométrica 2 porque nos ayuda a visualizar hacia qué valor de tiempo tiende el algoritmo.
Los asteriscos en las tablas de datos simbolizan que esos valores están por debajo del umbral de confianza, por lo que utilizamos el método del promedio para tener una medida más precisa.













CONCLUSIONES

Después de comprobar que los algoritmos llevan al mismo resultado para cada  valor de entrada, analizamos la complejidad de cada algoritmo para saber cuál es el mas óptimo,es decir, el que utiliza menor tiempo de ejecución para la misma tarea.
Para cada algoritmo creamos varias cotas con el fin de averiguar su complejidad de manera empírica:
- Ordenación por inserción.
       - En orden ascendente. Hallamos las cotas n^0.8, n^1 y n^1.2.
       - En orden descendente. Hallamos las cotas n^1.8, n^2 y n^2.2.
       - En orden aleatorio. Hallamos las cotas n^1.8, n^2 y n^2.2.

- Ordenación Shell.
       - En orden ascendente. Hallamos las cotas n^1, n^1.2 y n^1.4.
       - En orden descendente. Hallamos las cotas n^1, n^1.2 y n^1.4.
       - En orden aleatorio. Hallamos las cotas n^1, n^1.25 y n^1.4.


Para establecer la eficiencia de cada algoritmo de forma empírica, comparamos las cotas y los tiempos de ejecución resultantes de ambos algoritmos en cada uno de los órdenes del vector.
Deducimos de los resultados obtenidos, que el algoritmo óptimo para resolver el problema para ordenar el vector en cada caso es:
- En orden ascendente. Resulta más eficiente el algoritmo ins_sort.
- En orden descendente. Resulta más eficiente el algoritmo shell_sort.
- En orden aleatorio. Resulta más eficiente el algoritmo shell_sort.

De los datos obtenidos, comprobamos que el algoritmo shell_sort es más eficiente en 2/3 casos, siendo el caso del vector ordenado el que supera la eficiencia del algoritmo shell_sort.
