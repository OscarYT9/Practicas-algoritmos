
Óscar Vilela Rodríguez y Ainhoa de Diego Silva 
oscar.vilela.rodriguez@udc.es; ainhoa.dediego.silva@udc.es

INTRODUCCIÓN

En esta tercera práctica analizamos y demostramos de manera empírica la fiabilidad, tiempo de ejecución, y 
complejidad de de dos algoritmos propuestos: crearMonticulo, y ordenacionPorMonticulos que realiza la ordenación ascedente de un 
vector, que se inizializa de tres formas posibles; ascedente, descendente y aleatorio. 

Ambas funciones requieren la implementación de un monticulo de mínimos para su ejecución por lo que hubo que implementar una 
clase montículo con los métodos de crearMonticulo, consultarMenor, quitarMenor y __hundir. 
Para ello, creamos un programa en Python, compuesto de varios archivos de código: 

Algoritmos.py 
FuncionesTests.py 
FuncionesAuxiliares.py 
Main.py

ACLARACIONES INICIALES

Para ejecutar el código debes moverte al directorio y escribir en la terminal python main.py.

Las características de la máquina que usamos se muestran a continuación: 

Nombre del modelo: Lenovo Legion 5 15ITH6H Intel Core i7-11800H/32GB/1TB SSD/RTX3070/15.6" 
Procesador Intel Core i7-11800H (8C / 16T, 2.3 / 4.6GHz, 24MB) 
Memoria RAM 2x 16GB SO-DIMM DDR4-3200 
Almacenamiento 1TB SSD M.2 2280 PCIe 3.0x4 NVMe 
Python 3.9.12

*Este programa en específico se ejecutó en el procesador (CPU) por lo que la tarjeta gráfica (GPU) no es necesaria para su ejecución. 
*Todas las medidas de tiempo han sido tomadas en nanosegundos (ns), mediante la función 	time.perf_counter_ns(), y 
 mostradas por pantalla a su vez en nanosegundos. 

*Todas las funciones aquí comentadas están descritas en mayor profundidad en el código. 


Una vez aclaradas las cuestiones básicas, explicaremos paso a paso, el proceso que nos llevó a las conclusiones finales de este informe.






DESARRROLLO DE LAS PRUEBAS



1º Creamos el archivo Algoritmos.py en el que definimos la clase montículo, que es una estructura de datos (de mínimos en este caso)
que se utiliza para organizar y gestionar un conjunto de elementos de tal manera que se pueda acceder eficientemente al elemento más 
pequeño en cualquier momento. 

Además, definimos una función fuera de la clase para facilitar la creación de montículos.

class Monticulo:

    def crearMonticulo(self, v):

    def consultarMenor(self):

    def quitarMenor(self):

    def __hundir(self, i):

def ordenacionPorMonticulos(V):

Dentro de esta clase, definimos varios métodos para operar sobre el objeto Montículo.

def crearMonticulo(self, v: array): 

       Esta método se encarga de crear un montículo a partir de un array dado (v) y ordenarlo a través del 
       método _hundir (self, i) para poder trabajar con el montículo ya listo.

def consultarMenor(self):

       Este método comprueba si el montículo no tiene elementos, es decir, si esta vacío o si tiene algún elemento.
       En el caso de tener algún elemento, devuelve el elemento en la primera posición.

def quitarMenor(self): --> menor: int

       Este método elimina y devuelve el elemento menor del montículo. 
       Además, se encarga de formatear el montículo para que quede listo para operar con él.

def __hundir(self, i):

       El método ejecuta una de las operaciones básicas que incluye el montículo. Es el encargado de restaurar la propiedad del 
       montículo a la hora de crearlo y ordenarlo para poder operar con él o después de que un elemento se haya eliminado y 
       reemplazado por otro en la raíz del montículo.

Además, fuera de la clase, definimos la siguiente función.

def ordenacionPorMonticulos(V):

       Esta función permite una automatización de la creación de montículos dado un array ordenado de forma ascendente,
       descendente o aleatorio.




2º Comprobamos el correcto funcionamiento de los dos algoritmos y la complejidad algorítmica de forma empírica:

Para ello creamos el archivo FuncionesTests.py, que a su vez utiliza otras funciones definidas en FuncionesAuxiliares.py, donde definimos las funciones “test”: 

def probar_operaciones_monticulo(n,orden):

      La función se utiliza para probar las operaciones básicas de un montículo, incluyendo la creación del montículo,
      la inserción de elementos y la eliminación del elemento más pequeño, con el propósito de demostrar cómo funciona 
      un montículo en la práctica.

def probar_algoritmo_ordenación(n,orden):

        La función se utiliza para probar y demostrar el funcionamiento del algoritmo de ordenación por montículos en un vector, 
        mostrando cómo se ordena el vector al final de la ejecución.


Test 1 (Casos de Prueba):
Prueba con vector ascendente
Creamos el montículo vacío
Tamaño montículo: 0, Vector montículo: []

Creamos el montículo de mínimos con el vector ascendente
Tamaño montículo: 5, Vector montículo: [1, 2, 3, 4, 5] 

Eliminamos el menor en cada iteración
El menor elemento eliminado es: 1
Tamaño montículo: 4, Vector montículo: [2, 4, 3, 5]
El menor elemento eliminado es: 2
Tamaño montículo: 3, Vector montículo: [3, 4, 5]
El menor elemento eliminado es: 3
Tamaño montículo: 2, Vector montículo: [4, 5]
El menor elemento eliminado es: 4
Tamaño montículo: 1, Vector montículo: [5]
El menor elemento eliminado es: 5
Tamaño montículo: 0, Vector montículo: []
________________________________________________________
Prueba con vector descendente
Creamos el montículo vacío
Tamaño montículo: 0, Vector montículo: []

Creamos el montículo de mínimos con el vector descendente
Tamaño montículo: 5, Vector montículo: [1, 2, 3, 5, 4] 

Eliminamos el menor en cada iteración
El menor elemento eliminado es: 1
Tamaño montículo: 4, Vector montículo: [2, 4, 3, 5]
El menor elemento eliminado es: 2
Tamaño montículo: 3, Vector montículo: [3, 4, 5]
El menor elemento eliminado es: 3
Tamaño montículo: 2, Vector montículo: [4, 5]
El menor elemento eliminado es: 4
Tamaño montículo: 1, Vector montículo: [5]
El menor elemento eliminado es: 5
Tamaño montículo: 0, Vector montículo: []
________________________________________________________
Prueba con vector aleatorio
Creamos el montículo vacío
Tamaño montículo: 0, Vector montículo: []

Creamos el montículo de mínimos con el vector aleatorio
Tamaño montículo: 5, Vector montículo: [-5, -5, 4, 0, 2] 

Eliminamos el menor en cada iteración
El menor elemento eliminado es: -5
Tamaño montículo: 4, Vector montículo: [-5, 0, 4, 2]
El menor elemento eliminado es: -5
Tamaño montículo: 3, Vector montículo: [0, 2, 4]
El menor elemento eliminado es: 0
Tamaño montículo: 2, Vector montículo: [2, 4]
El menor elemento eliminado es: 2
Tamaño montículo: 1, Vector montículo: [4]
El menor elemento eliminado es: 4
Tamaño montículo: 0, Vector montículo: []
________________________________________________________
Vector ascendente sin ordenar: [1, 2, 3, 4, 5] True
Arreglo ascendente ordenado: [1, 2, 3, 4, 5] True
Vector descendente sin ordenar: [5, 4, 3, 2, 1] False
Arreglo descendente ordenado: [1, 2, 3, 4, 5] True
Vector aleatorio sin ordenar: [1, 3, -2, -1, -2] False
Arreglo aleatorio ordenado: [-2, -2, -1, 1, 3] True


3º Para comprobar el tiempo de ejecución de los dos algoritmos (el de creación y ordenación), creamos una función 
def test_tiempo_complejidad(alg, orden, exp1, exp2, exp3) que calcula
el tiempo y nos permite medir la complejidad de manera empírica gracias a las cotas.

Utilizamos un vector de progresión geométrica 2 porque nos ayuda a visualizar hacia qué valor de tiempo tiende el algoritmo.
Los asteriscos en las tablas de datos simbolizan que esos valores están por debajo del umbral de confianza, por lo que utilizamos 
el método del promedio para tener una medida más precisa.


Test 2 (Análisis de Complejidad): (Iteración nº 5)
Creación montículo (orden ascendente)
                                                     Subestimada    Ajustada  Sobreestimada
           n                  t(n) (ns)            t(n)/n^0.8       t(n)/n^1     t(n)/n^1.2
*        500                211398.8000           1465.299881     # 422.797600     121.994012 (promedio de 1000 repeticiones)
*       1000                420815.8000           1675.297875     # 420.815800     105.704150 (promedio de 1000 repeticiones)
        2000               1262900.0000           2887.652750     # 631.450000     138.080696
        4000               1721000.0000           2260.127176     # 430.250000      81.904711
        8000               3473100.0000           2619.662229     # 434.137500      71.946439
       16000               7390900.0000           3201.852638     461.931250      66.642817
       32000              14908300.0000           3709.438207     465.884375      58.512432
       64000              29866500.0000           4268.156667     466.664062      51.023279
      128000              58472300.0000           4799.347554     456.814844      43.480869
      256000             114039300.0000           5376.040980     445.466016      36.911916
      512000             227515900.0000           6160.213782     444.366992      32.054411
     1024000             453626700.0000           7054.376642     442.994824      27.818817
     
La complejidad de la función crear montículo en orden ascendente es, aproximadamente y comprobado de forma empírica, de O(n^1).
En cuánto a las cotas, podemos observar de foma empírica como los valores de la subestimada tienden al infinito, los de la ajustada 
tienden a un rango de valores entre 440 y 460 y los de la sobreestimada que tienden a 0. 

Creación montículo (orden descendente)
                                                     Subestimada    Ajustada  Sobreestimada
           n                  t(n) (ns)            t(n)/n^0.8       t(n)/n^1     t(n)/n^1.2
*        500                353816.5000           2452.460824     # 707.633000     204.180413 (promedio de 1000 repeticiones)
*       1000                695816.9000           2770.096973     # 695.816900   174.781303 (promedio de 1000 repeticiones)
        2000               1447100.0000           3308.830703     723.550000     158.220426
        4000               3248000.0000           4265.481154     # 812.000000   154.576700
        8000               5840700.0000           4405.476716     730.087500     120.992072
       16000              12267700.0000           5314.558120     # 766.731250   110.616310
       32000              24226900.0000           6028.064131     # 757.090625      95.086283
       64000              47592000.0000           6801.269385     743.625000      81.305137
      128000              92940000.0000           7628.421692     726.093750      69.111561
      256000             184251800.0000           8685.998840     719.733594      59.638098
      512000             370063900.0000          10019.839216     722.781055      52.137808
     1024000             752230400.0000          11697.981100     734.600000      46.130794

La complejidad de la función crear montículo en orden descendente es, aproximadamente y comprobado de forma empírica, de O(n^1).
En cuánto a las cotas, podemos observar de foma empírica como los valores de la subestimada tienden al infinito, los de la ajustada 
tienden a un rango de valores entre 720 y 740 y los de la sobreestimada que tienden a 0.

Creación montículo (orden aleatorio)
                                                    Subestimada    Ajustada  Sobreestimada
           n                  t(n) (ns)            t(n)/n^0.8       t(n)/n^1     t(n)/n^1.2
*        500                319899.9000           2217.369660     # 639.799800     184.607822 (promedio de 1000 repeticiones)
*       1000                647450.2000           2577.545672     # 647.450200     162.632137 (promedio de 1000 repeticiones)
        2000               1314000.0000           3004.494191     # 657.000000     143.667777
        4000               2847600.0000           3739.650288     711.900000     135.521124
        8000               5653800.0000           4264.503271     706.725000     117.120376
       16000              11243700.0000           4870.945421     702.731250     101.383031
       32000              22779100.0000           5667.826905     711.846875      89.403925
       64000              43588400.0000           6229.123602     681.068750      74.465474
      128000              86131700.0000           7069.603278     672.903906      64.048809
      256000             172991500.0000           8155.165748     675.748047      55.993396
      512000             352276700.0000           9538.233514     688.040430      49.631793
     1024000             715803300.0000          11131.501033     699.026660      43.896890
     
La complejidad de la función crear montículo en orden aleatorio es, aproximadamente y comprobado de forma empírica, de O(n^1).
En cuánto a las cotas, podemos observar de foma empírica como los valores de la subestimada tienden al infinito, los de la ajustada tienden 
a un rango de valores entre 680 y 712 y los de la sobreestimada que tienden a 0.

     Ordenación del vector (orden ascendente)
                                                     Subestimada    Ajustada  Sobreestimada
           n                  t(n) (ns)              t(n)/n^1  t(n)/n*log(n)     t(n)/n^1.3
         500               1803700.0000           3607.400000     # 402.351862     559.117776
        1000               3632800.0000           3632.800000     364.527256     457.342424
        2000               8261900.0000           4130.950000     # 376.712681     422.416564
        4000              18361400.0000           4590.350000     # 383.622995     381.265759
        8000              38677100.0000           4834.637500     # 372.876595     326.164673
       16000              81906200.0000           5119.137500     366.548516     280.518043
       32000             172649300.0000           5395.290625     360.508378     240.142955
       64000             366092100.0000           5720.189062     358.277988     206.802789
      128000             767265300.0000           5994.260156     353.314651     176.024288
      256000            1663653600.0000           6498.646875     361.723528     155.006871
      512000            3506412000.0000           6848.460938     361.095583     132.681996
     1024000            7361175900.0000           7188.648340     360.048383     113.124651

La complejidad de la función ordenación del vector en orden ascendente es, aproximadamente y comprobado de forma empírica, de O(n*log(n)).
En cuánto a las cotas, podemos observar de foma empírica como los valores de la subestimada tienden al infinito, los de la ajustada tienden 
a un rango de valores entre 350 y 360 y los de la sobreestimada que tienden a 0.   
     Ordenación del vector (orden descendente)

Ordenación del vector (orden descendente)
                                                     Subestimada    Ajustada  Sobreestimada
           n                  t(n) (ns)              t(n)/n^1  t(n)/n*log(n)     t(n)/n^1.3
         500               1847800.0000           3695.600000     # 412.189261     572.788061
        1000               4037900.0000           4037.900000     # 405.176340     508.341492
        2000               8989700.0000           4494.850000     # 409.897722     459.627711
        4000              20167100.0000           5041.775000     # 421.349314     418.760262
        8000              42286700.0000           5285.837500     # 407.675879     356.604494
       16000              88047200.0000           5502.950000     # 394.030861     301.550166
       32000             188811200.0000           5900.350000     # 394.255983     262.623014
       64000             389540100.0000           6086.564062     381.225498     220.048395
      128000             822673100.0000           6427.133594     378.829147     188.735822
      256000            1731898300.0000           6765.227734     376.561781     161.365405
      512000            3630995200.0000           7091.787500     373.925349     137.396201
     1024000            7759153300.0000           7577.298145     379.514175     119.240665

La complejidad de la función ordenación del vector en orden descendente es, aproximadamente y comprobado de forma empírica, de O(n*log(n)).
En cuánto a las cotas, podemos observar de foma empírica como los valores de la subestimada tienden al infinito, los de la ajustada tienden 
a un rango de valores entre 370 y 380 y los de la sobreestimada que tienden a 0. 


Ordenación del vector (orden aleatorio)
                                                     Subestimada    Ajustada  Sobreestimada
           n                  t(n) (ns)              t(n)/n^1  t(n)/n*log(n)     t(n)/n^1.3
         500               1723800.0000           3447.600000     384.528547     534.350070
        1000               3840200.0000           3840.200000     385.338463     483.452537
        2000               8744100.0000           4372.050000     398.699253     447.070611
        4000              19531300.0000           4882.825000     # 408.065605     405.558177
        8000              40872700.0000           5109.087500     394.043846     344.680207
       16000              86741200.0000           5421.325000     388.186219     297.077287
       32000             183427300.0000           5732.103125     383.013881     255.134390
       64000             391561300.0000           6118.145312     383.203556     221.190156
      128000             827385100.0000           6463.946094     380.998956     189.816838
      256000            1804530700.0000           7048.948047     392.354040     168.132751
      512000            3816257600.0000           7453.628125     393.003949     144.406497
     1024000            8667457300.0000           8464.313770     # 423.940961     133.199246

La complejidad de la función ordenación del vector en orden aleatorio es, aproximadamente y comprobado de forma empírica, de O(n*log(n)).
En cuánto a las cotas, podemos observar de foma empírica como los valores de la subestimada tienden al infinito, los de la ajustada tienden 
a un rango de valores entre 380 y 400 y los de la sobreestimada que tienden a 0. 


Para intentar evitar datos anómalos, ejecutamos el código en un entorno lo más limpio posible, con el menor número de procesos en segundo plano, 
con un número de iteraciones totales de 10.

Para indicar los datos anómalos, los marcamos en las tablas de los tiempos de ejecución con el símbolo "#".


CONCLUSIONES
 
Para cada algoritmo creamos varias cotas con el fin de averiguar su complejidad de manera empírica:
- Creación de montículo.
       - En orden ascendente. Hallamos las cotas n^0.8, n^1 y n^1.2.
       - En orden descendente. Hallamos las cotas n^0.8, n^1 y n^1.2.
       - En orden aleatorio. Hallamos las cotas n^0.8, n^1 y n^1.2.

- Ordenación de un vector.
       - En orden ascendente. Hallamos las cotas n^1, n*log(n) y n^1.3.
       - En orden descendente. Hallamos las cotas n^1, n*log(n) y n^1.3.
       - En orden aleatorio. Hallamos las cotas n^1, n*log(n) y n^1.3.


Para establecer la eficiencia de cada algoritmo de forma empírica, comparamos las cotas y los tiempos de ejecución resultantes de ambos algoritmos 
en cada uno de los órdenes del vector.

De los datos obtenidos, comprobamos que el algoritmo de creación de montículo es más eficiente que el de ordenación de un vector, ya que su complejidad es lineal mientras que la de otra es O(n) = n*log(n).
Puede comprobarse más facilmente el crecimiento de las dos funciones en el siguiente enlace: https://m.wolframalpha.com/input?i=y+%3D+xlogx%2C++y%3Dx%5E1+%2C+x+from+1+to+100&lang=es
Así pues, vemos que la función n*log(n) tiene un crecimiento superior que la función x^1, comprobando así que el tiempo del algoritmo que crea los montículos es sustancialmente inferior al tiempo que tarda la otra función en ordenar vectores.
Aunque en este caso puede llegar a tener menos sentido la comparación entre los dos algoritmos, más hallá de resaltar su complejidad empírica, ya que realizan funciones diferentes.